{"version":3,"file":"static/js/6604.9a686446.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/extensions/erc1155/__generated__/IERC1155/read/totalSupply.ts","../node_modules/thirdweb/src/extensions/erc1155/__generated__/IERC1155/read/uri.ts","../node_modules/thirdweb/src/extensions/erc1155/read/getNFT.ts","../node_modules/thirdweb/src/utils/nft/fetchTokenMetadata.ts","../node_modules/thirdweb/src/utils/base64/base64.ts","../node_modules/thirdweb/src/utils/nft/parseNft.ts"],"sourcesContent":["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"totalSupply\" function.\n */\nexport type TotalSupplyParams = {\n  id: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"id\" }>;\n};\n\nexport const FN_SELECTOR = \"0xbd85b039\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"id\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `totalSupply` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `totalSupply` method is supported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isTotalSupplySupported } from \"thirdweb/extensions/erc1155\";\n *\n * const supported = await isTotalSupplySupported(contract);\n * ```\n */\nexport async function isTotalSupplySupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"totalSupply\" function.\n * @param options - The options for the totalSupply function.\n * @returns The encoded ABI parameters.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeTotalSupplyParams } \"thirdweb/extensions/erc1155\";\n * const result = encodeTotalSupplyParams({\n *  id: ...,\n * });\n * ```\n */\nexport function encodeTotalSupplyParams(options: TotalSupplyParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.id]);\n}\n\n/**\n * Encodes the \"totalSupply\" function into a Hex string with its parameters.\n * @param options - The options for the totalSupply function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeTotalSupply } \"thirdweb/extensions/erc1155\";\n * const result = encodeTotalSupply({\n *  id: ...,\n * });\n * ```\n */\nexport function encodeTotalSupply(options: TotalSupplyParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeTotalSupplyParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the totalSupply function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1155\n * @example\n * ```ts\n * import { decodeTotalSupplyResult } from \"thirdweb/extensions/erc1155\";\n * const result = decodeTotalSupplyResult(\"...\");\n * ```\n */\nexport function decodeTotalSupplyResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"totalSupply\" function on the contract.\n * @param options - The options for the totalSupply function.\n * @returns The parsed result of the function call.\n * @extension ERC1155\n * @example\n * ```ts\n * import { totalSupply } from \"thirdweb/extensions/erc1155\";\n *\n * const result = await totalSupply({\n *  contract,\n *  id: ...,\n * });\n *\n * ```\n */\nexport async function totalSupply(\n  options: BaseTransactionOptions<TotalSupplyParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.id],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"uri\" function.\n */\nexport type UriParams = {\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"tokenId\" }>;\n};\n\nexport const FN_SELECTOR = \"0x0e89341c\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"tokenId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `uri` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `uri` method is supported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isUriSupported } from \"thirdweb/extensions/erc1155\";\n *\n * const supported = await isUriSupported(contract);\n * ```\n */\nexport async function isUriSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"uri\" function.\n * @param options - The options for the uri function.\n * @returns The encoded ABI parameters.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeUriParams } \"thirdweb/extensions/erc1155\";\n * const result = encodeUriParams({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeUriParams(options: UriParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId]);\n}\n\n/**\n * Encodes the \"uri\" function into a Hex string with its parameters.\n * @param options - The options for the uri function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeUri } \"thirdweb/extensions/erc1155\";\n * const result = encodeUri({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeUri(options: UriParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeUriParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the uri function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1155\n * @example\n * ```ts\n * import { decodeUriResult } from \"thirdweb/extensions/erc1155\";\n * const result = decodeUriResult(\"...\");\n * ```\n */\nexport function decodeUriResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"uri\" function on the contract.\n * @param options - The options for the uri function.\n * @returns The parsed result of the function call.\n * @extension ERC1155\n * @example\n * ```ts\n * import { uri } from \"thirdweb/extensions/erc1155\";\n *\n * const result = await uri({\n *  contract,\n *  tokenId: ...,\n * });\n *\n * ```\n */\nexport async function uri(options: BaseTransactionOptions<UriParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.tokenId],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { type NFT, parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport { totalSupply } from \"../__generated__/IERC1155/read/totalSupply.js\";\nimport { uri } from \"../__generated__/IERC1155/read/uri.js\";\n\n/**\n * Parameters for getting an NFT.\n */\nexport type GetNFTParams = {\n  tokenId: bigint;\n};\n\n/**\n * Retrieves information about a specific ERC1155 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc1155\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n */\nexport async function getNFT(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const [tokenUri, supply] = await Promise.all([\n    uri({\n      contract: options.contract,\n      tokenId: options.tokenId,\n    }),\n    totalSupply({\n      contract: options.contract,\n      id: options.tokenId,\n      // in cases where the supply is not available -> fall back to 0\n    }).catch(() => 0n),\n  ]);\n  return parseNFT(\n    await fetchTokenMetadata({\n      client: options.contract.client,\n      tokenId: options.tokenId,\n      tokenUri,\n    }).catch(() => ({\n      id: options.tokenId,\n      type: \"ERC1155\",\n      uri: tokenUri,\n    })),\n    {\n      tokenId: options.tokenId,\n      tokenUri,\n      type: \"ERC1155\",\n      owner: null,\n      supply,\n    },\n  );\n}\n","import type { ThirdwebClient } from \"../../client/client.js\";\nimport { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\nimport type { NFTMetadata } from \"./parseNft.js\";\n\n/**\n * @internal\n */\nexport type FetchTokenMetadataOptions = {\n  client: ThirdwebClient;\n  tokenId: bigint;\n  tokenUri: string;\n};\n\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(\n  options: FetchTokenMetadataOptions,\n): Promise<NFTMetadata> {\n  const { client, tokenId, tokenUri } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\n        \"Failed to fetch base64 encoded NFT\",\n        { tokenId, tokenUri },\n        e,\n      );\n      throw e;\n    }\n  }\n\n  // in all other cases we will need the `download` function from storage\n  const { download } = await import(\"../../storage/download.js\");\n\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({ client, uri: tokenUri })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\n            \"{id}\",\n            numberToHex(tokenId, { size: 32 }).slice(2),\n          ),\n        })\n      ).json();\n    } catch (err) {\n      // otherwise attempt the second format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\"{id}\", tokenId.toString()),\n        })\n      ).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n}\n","import { base64ToString } from \"../uint8-array.js\";\n\ntype Base64Prefix = \"data:application/json;base64\";\ntype Base64String = `${Base64Prefix},${string}`;\n\n/**\n * Checks if a given string is a base64 encoded JSON string.\n * @param input - The string to be checked.\n * @returns True if the input string starts with \"data:application/json;base64\", false otherwise.\n * @example\n * ```ts\n * isBase64JSON(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // true\n * ```\n */\nexport function isBase64JSON(input: string): input is Base64String {\n  if (input.startsWith(\"data:application/json;base64\")) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Parses a base64 string and returns the decoded string.\n * @param input - The base64 string to parse.\n * @returns The decoded string.\n * @example\n * ```ts\n * parseBase64String(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // '{\"test\":\"base64\"}'\n * ```\n */\nexport function parseBase64String(input: Base64String) {\n  const [, base64] = input.split(\",\") as [Base64Prefix, string];\n  return base64ToString(base64);\n}\n","import type { FileOrBufferOrString } from \"../../storage/upload/types.js\";\nimport type { Prettify } from \"../type-utils.js\";\n\n/**\n * Represents the input data for creating an NFT (Non-Fungible Token).\n */\nexport type NFTInput = Prettify<\n  {\n    name?: string;\n    description?: string;\n    image?: FileOrBufferOrString;\n    animation_url?: FileOrBufferOrString;\n    external_url?: FileOrBufferOrString;\n    background_color?: string;\n    // TODO check if we truly need both of these?\n    properties?: Record<string, unknown> | Array<Record<string, unknown>>;\n  } & Record<string, unknown>\n>;\n\nexport type NFTMetadata = {\n  id: bigint;\n  uri: string;\n  name?: string;\n  description?: string;\n  image?: string;\n  animation_url?: string;\n  external_url?: string;\n  background_color?: string;\n  properties?: Record<string, unknown>;\n  attributes?: Record<string, unknown>;\n} & Record<string, unknown>;\n\nexport type NFT =\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC721\";\n    }\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC1155\";\n      supply: bigint;\n    };\n\n/**\n * @internal\n */\nexport type ParseNFTOptions =\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC721\";\n      owner?: string | null;\n    }\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC1155\";\n      owner?: string | null;\n      supply: bigint;\n    };\n\n/**\n * Parses the NFT metadata and options to create an NFT object.\n * @param base - The base NFT metadata.\n * @param options - The options for parsing the NFT.\n * @returns The parsed NFT object.\n * @internal\n */\nexport function parseNFT(base: NFTMetadata, options: ParseNFTOptions): NFT {\n  switch (options.type) {\n    case \"ERC721\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n      };\n    case \"ERC1155\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n        supply: options.supply,\n      };\n    default:\n      throw new Error(\"Invalid NFT type\");\n  }\n}\n"],"names":["FN_SELECTOR","FN_INPUTS","type","name","FN_OUTPUTS","async","totalSupply","options","readContract","contract","method","params","id","uri","tokenId","getNFT","tokenUri","supply","Promise","all","catch","parseNFT","fetchTokenMetadata","client","owner","startsWith","JSON","parse","input","base64","split","base64ToString","parseBase64String","e","console","error","download","includes","json","replace","numberToHex","size","slice","err","toString","base","_options$owner","_options$owner2","metadata","tokenURI","Error"],"sourceRoot":""}