{"version":3,"file":"static/js/81436.b1df17b4.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/utils/bigint.ts","../node_modules/thirdweb/src/transaction/actions/zksync/getEip721Domain.ts","../node_modules/thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts","../node_modules/thirdweb/src/utils/encoding/helpers/concat-hex.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts","../node_modules/thirdweb/src/event/prepare-event.ts","../node_modules/thirdweb/src/event/utils.ts","../node_modules/thirdweb/src/wallets/smart/lib/utils.ts","../node_modules/thirdweb/src/wallets/smart/lib/bundler.ts","../node_modules/thirdweb/src/event/actions/parse-logs.ts","../node_modules/thirdweb/src/wallets/smart/lib/paymaster.ts","../node_modules/thirdweb/src/wallets/smart/lib/userop.ts","../node_modules/thirdweb/src/wallets/smart/lib/calls.ts","../node_modules/thirdweb/src/wallets/smart/index.ts","../node_modules/viem/utils/encoding/toRlp.ts"],"sourcesContent":["import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n","import type { TransactionSerializable } from \"viem\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type {\n  EIP721SerializedTransaction,\n  EIP721TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP721TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP721SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    // TODO suport factoryDeps\n    factoryDeps: [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n","import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\nexport type SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit);\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n","import type { Hex } from \"./is-hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace(\"0x\", \"\"),\n    \"\",\n  )}`;\n}\n","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n","import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { type Hex, encodeEventTopics, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n","import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n","import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport { isHex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type { UserOperation, UserOperationHexed } from \"../types.js\";\n\nconst generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport const randomNonce = () => {\n  return BigInt(\n    concat([numberToHex(generateRandomUint192()), \"0x0000000000000000\"]),\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(userOp: UserOperation): UserOperationHexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationHexed;\n}\n\nexport function isNativeAAChain(chain: Chain) {\n  return chain.id === 324 || chain.id === 300 || chain.id === 302;\n}\n","import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport type {\n  BundlerOptions,\n  EstimationResult,\n  GasPriceResult,\n  PmTransactionData,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * @internal\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: hexToBigInt(res.verificationGas),\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n  };\n}\n\n/**\n * @internal\n */\nexport async function getUserOpGasPrice(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * @internal\n */\nexport async function getUserOpReceipt(args: {\n  userOpHash: Hex;\n  options: BundlerOptions;\n}): Promise<TransactionReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(`UserOp failed at txHash: ${res.transactionHash}`);\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const bundlerUrl =\n    options.overrides?.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = JSON.stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n","import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    logs,\n    abi: events.map((e) => e.abiEvent),\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n","import { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport type {\n  PaymasterResult,\n  SmartAccountOptions,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultPaymasterUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * TODO Docs\n * @internal\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperation;\n  options: SmartAccountOptions;\n}): Promise<PaymasterResult> {\n  const { userOp, options } = args;\n\n  if (options.overrides?.paymaster) {\n    return options.overrides?.paymaster(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const client = options.client;\n  const paymasterUrl = getDefaultPaymasterUrl(options.chain);\n  const entrypoint =\n    options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n","import { concat } from \"viem\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { SmartAccountOptions, UserOperation } from \"../types.js\";\nimport { estimateUserOpGas, getUserOpGasPrice } from \"./bundler.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { randomNonce } from \"./utils.js\";\n\n/**\n * Create an unsigned user operation\n * @internal\n */\n/**\n * Creates an unsigned user operation.\n * @internal\n */\nexport async function createUnsignedUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<UserOperation> {\n  const { executeTx, options } = args;\n  const isDeployed = await isContractDeployed(options.accountContract);\n  const initCode = isDeployed ? \"0x\" : await getAccountInitCode(options);\n  const callData = await encode(executeTx);\n\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n  const bundlerUrl =\n    options.overrides?.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasPrice({\n      options,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(\n        options.client,\n        options.chain,\n      );\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n\n  // const nonce = BigInt(transaction.nonce || randomNonce());\n  const nonce = randomNonce(); // FIXME getNonce should be overrideable by the wallet\n\n  const partialOp: UserOperation = {\n    sender: options.accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (options.sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      options,\n    });\n    const paymasterAndData = paymasterResult.paymasterAndData;\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          options,\n        });\n        if (\n          paymasterResult2.paymasterAndData &&\n          paymasterResult2.paymasterAndData !== \"0x\"\n        ) {\n          partialOp.paymasterAndData = paymasterResult2.paymasterAndData as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\",\n  };\n}\n\n/**\n * Sign the filled userOp.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @internal\n */\nexport async function signUserOp(args: {\n  userOp: UserOperation;\n  options: SmartAccountOptions;\n}): Promise<UserOperation> {\n  const { userOp, options } = args;\n  const userOpHash = getUserOpHash({\n    userOp,\n    entryPoint: options.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n    chainId: options.chain.id,\n  });\n  if (options.personalAccount.signMessage) {\n    const signature = await options.personalAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: SmartAccountOptions): Promise<Hex> {\n  const { factoryContract } = options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    options,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\n/**\n * @internal\n */\nfunction getUserOpHash(args: {\n  userOp: UserOperation;\n  entryPoint: string;\n  chainId: number;\n}): Hex {\n  const { userOp, entryPoint, chainId } = args;\n  const hashedInitCode = keccak256(userOp.initCode);\n  const hashedCallData = keccak256(userOp.callData);\n  const hashedPaymasterAndData = keccak256(userOp.paymasterAndData);\n\n  const packedUserOp = encodeAbiParameters(\n    [\n      { type: \"address\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n      { type: \"bytes32\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n    ],\n    [\n      userOp.sender,\n      userOp.nonce,\n      hashedInitCode,\n      hashedCallData,\n      userOp.callGasLimit,\n      userOp.verificationGasLimit,\n      userOp.preVerificationGas,\n      userOp.maxFeePerGas,\n      userOp.maxPriorityFeePerGas,\n      hashedPaymasterAndData,\n    ],\n  );\n  const encoded = encodeAbiParameters(\n    [{ type: \"bytes32\" }, { type: \"address\" }, { type: \"uint256\" }],\n    [keccak256(packedUserOp), entryPoint, BigInt(chainId)],\n  );\n  return keccak256(encoded);\n}\n","import type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\nimport type { SmartAccountOptions, SmartWalletOptions } from \"../types.ts\";\n\n/**\n * @internal\n */\nexport async function predictAddress(\n  factoryContract: ThirdwebContract,\n  options: SmartWalletOptions & { personalAccountAddress?: string },\n): Promise<string> {\n  if (options.overrides?.predictAddress) {\n    return options.overrides.predictAddress(factoryContract);\n  }\n  if (options.overrides?.accountAddress) {\n    return options.overrides.accountAddress;\n  }\n  const adminAddress = options.personalAccountAddress;\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const extraData = stringToHex(options.overrides?.accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, extraData],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n}): PreparedTransaction {\n  const { factoryContract, options } = args;\n  if (options.overrides?.createAccount) {\n    return options.overrides.createAccount(factoryContract);\n  }\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [\n      options.personalAccount.address,\n      stringToHex(options.overrides?.accountSalt ?? \"\"),\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  transaction: SendTransactionOption;\n}): PreparedTransaction {\n  const { accountContract, options, transaction } = args;\n  if (options.overrides?.execute) {\n    return options.overrides.execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  transactions: SendTransactionOption[];\n}): PreparedTransaction {\n  const { accountContract, options, transactions } = args;\n  if (options.overrides?.executeBatch) {\n    return options.overrides.executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n","import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getUserOpReceipt,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { DEFAULT_ACCOUNT_FACTORY } from \"./lib/constants.js\";\nimport { createUnsignedUserOp, signUserOp } from \"./lib/userop.js\";\nimport { isNativeAAChain } from \"./lib/utils.js\";\nimport type {\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nexport const personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const factoryAddress = options.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY;\n  const chain = connectChain ?? options.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (isNativeAAChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress(factoryContract, {\n    personalAccountAddress: personalAccount.address,\n    ...options,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}. Are you on the right chain?`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account: Account = {\n    address: accountContract.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      const executeTx = prepareExecute({\n        accountContract,\n        options,\n        transaction,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        options,\n        transactions,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        console.log(\n          \"Account contract not deployed yet. Deploying account before signing message\",\n        );\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        console.log(\n          \"Account contract not deployed yet. Deploying account before signing message\",\n        );\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n  };\n  return account;\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            overrides: creationOptions.overrides,\n            chain,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          overrides: creationOptions.overrides,\n          chain,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    executeTx,\n    options,\n  });\n  const signedUserOp = await signUserOp({\n    options,\n    userOp: unsignedUserOp,\n  });\n  const userOpHash = await bundleUserOp({\n    options,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    options,\n    userOpHash,\n  });\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n\nasync function waitForUserOpReceipt(args: {\n  options: SmartAccountOptions;\n  userOpHash: Hex;\n}): Promise<TransactionReceipt> {\n  const { options, userOpHash } = args;\n  const timeout = 120000; // 2mins\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt({ options, userOpHash });\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n"],"names":["toBigInt","value","includes","Number","isInteger","Error","concat","Uint8Array","BigInt","uint8ArrayToHex","gasPerPubdataDefault","getEip712Domain","transaction","message","gas","nonce","to","from","maxFeePerGas","maxPriorityFeePerGas","paymaster","paymasterInput","gasPerPubdata","data","txType","gasLimit","gasPerPubdataByteLimit","factoryDeps","transactionToMessage","domain","name","version","chainId","types","Transaction","type","primaryType","async","signEip712Transaction","options","account","eip712Transaction","eip712Domain","customSignature","signTypedData","serializedTransaction","toHex","values","toRlp","reduce","acc","x","replace","serializeTransactionEIP712","populateEip712Transaction","Promise","all","encode","resolvePromisedValue","eip712","then","rpc","getRpcClient","result","method","params","address","numberToHex","undefined","gas_limit","max_fee_per_gas","max_priority_fee_per_gas","gas_per_pubdata_limit","toSerializableTransaction","userOperationRevertReasonEvent","signature","resolvedSignature","item","parseAbiItem","abiEvent","hash","toEventHash","topics","encodeEventTopics","abi","args","filters","prepareEvent","arguments","length","generateRandomUint192","rand1","Math","floor","random","rand2","rand3","rand4","rand5","rand6","randomNonce","hexlifyUserOp","userOp","Object","fromEntries","entries","map","_ref","key","val","isHex","estimateUserOpGas","_args$options$overrid3","_args$options$overrid4","res","sendBundlerRequest","operation","overrides","entrypointAddress","ENTRYPOINT_ADDRESS_v0_6","preVerificationGas","hexToBigInt","verificationGas","verificationGasLimit","callGasLimit","MANAGED_ACCOUNT_GAS_BUFFER","getUserOpReceipt","userOpHash","success","_logs$","revertReason","logs","events","strict","viem_parseEventLogs","e","parseEventLogs","transactionHash","revertMsg","decodeErrorResult","join","receipt","_options$overrides$bu","_options$overrides","DEBUG","console","debug","bundlerUrl","getDefaultBundlerUrl","chain","fetchWithHeaders","getClientFetch","client","response","headers","body","stringify","jsonrpc","id","json","ok","error","statusText","JSON","code","status","getPaymasterAndData","_options$overrides$en","_options$overrides3","_res$error","_options$overrides2","paymasterUrl","getDefaultPaymasterUrl","entrypoint","paymasterAndData","createUnsignedUserOp","executeTx","initCode","isContractDeployed","accountContract","factoryContract","deployTx","_options$overrides4","_options$overrides$ac2","_options$overrides5","createAccount","prepareContractCall","contract","personalAccount","stringToHex","accountSalt","prepareCreateAccount","getAccountInitCode","callData","isThirdwebUrl","bundlerGasPrice","getUserOpGasPrice","resolvedMaxFeePerGas","resolvedMaxPriorityFeePerGas","_ref2","feeData","getDefaultGasOverrides","partialOp","sender","DUMMY_SIGNATURE","sponsorGas","paymasterResult","estimates","paymasterResult2","signUserOp","entryPoint","hashedInitCode","keccak256","hashedCallData","hashedPaymasterAndData","packedUserOp","encodeAbiParameters","encoded","getUserOpHash","signMessage","raw","hexToBytes","isSmartWallet","wallet","personalAccountToSmartAccountMap","WeakMap","smartWalletToPersonalAccountMap","connectSmartWallet","connectionOptions","creationOptions","_options$factoryAddre","connectChain","factoryAddress","DEFAULT_ACCOUNT_FACTORY","gasless","isNativeAAChain","createZkSyncAccount","getContract","accountAddress","_options$overrides$ac","predictAddress","adminAddress","personalAccountAddress","extraData","readContract","catch","err","cause","sendTransaction","_options$overrides6","execute","prepareExecute","_sendUserOp","sendBatchTransaction","transactions","_options$overrides7","executeBatch","tx","prepareBatchExecute","hashMessage","checkContractWalletSignature","log","_deployAccount","originalMsgHash","sig","factorySupports712","wrappedMessageHash","verifyingContract","AccountMessage","_typedData","_typedData$domain","_accountContract$addr","typedData","parseTypedData","checkContractWalletSignedTypedData","toLowerCase","hashTypedData","onTransactionRequested","_options$personalAcco","_options$personalAcco2","call","createSmartAccount","set","disconnectSmartWallet","get","delete","_transaction$to","_transaction$value","prepTx","getCachedChain","serializableTransaction","pmData","getZkPaymasterData","signedTransaction","txHash","broadcastZkTransaction","_connectionOptions$pe","_connectionOptions$pe2","prepareTransaction","dummyTx","unsignedUserOp","signedUserOp","_args$options$overrid","_args$options$overrid2","bundleUserOp","timeout","interval","endtime","Date","now","userOpReceipt","resolve","setTimeout","waitForUserOpReceipt","bytes","encodable","getEncodable","cursor","createCursor","bytesToHex","Array","isArray","list","bodyLength","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","sizeOfBytesLength","pushBytes","getEncodableBytes","BaseError"],"sourceRoot":""}