{"version":3,"file":"static/js/91688.4006bb76.chunk.js","mappings":"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","sources":["../node_modules/viem/utils/transaction/assertTransaction.ts","../node_modules/viem/utils/transaction/serializeAccessList.ts","../node_modules/viem/utils/transaction/serializeTransaction.ts","../node_modules/thirdweb/src/gas/estimate-l1-fee.ts","../node_modules/viem/utils/encoding/toRlp.ts"],"sourcesContent":["import { versionedHashVersionKzg } from '../../constants/kzg.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n  InvalidVersionedHashSizeError,\n  type InvalidVersionedHashSizeErrorType,\n  InvalidVersionedHashVersionError,\n  type InvalidVersionedHashVersionErrorType,\n} from '../../errors/blob.js'\nimport {\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from '../../errors/chain.js'\nimport {\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n} from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nexport type AssertTransactionEIP4844ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | EmptyBlobErrorType\n  | InvalidVersionedHashSizeErrorType\n  | InvalidVersionedHashVersionErrorType\n  | ErrorType\n\nexport function assertTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n) {\n  const { blobVersionedHashes } = transaction\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\n    for (const hash of blobVersionedHashes) {\n      const size_ = size(hash)\n      const version = hexToNumber(slice(hash, 0, 1))\n      if (size_ !== 32)\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\n      if (version !== versionedHashVersionKzg)\n        throw new InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP1559ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | TipAboveFeeCapErrorType\n  | ErrorType\n\nexport function assertTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n\nexport type AssertTransactionEIP2930ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n\nexport type AssertTransactionLegacyErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n) {\n  const {\n    chainId,\n    maxPriorityFeePerGas,\n    gasPrice,\n    maxFeePerGas,\n    to,\n    accessList,\n  } = transaction\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new InvalidChainIdError({ chainId })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n  if (accessList)\n    throw new BaseError(\n      '`accessList` is not a valid Legacy Transaction attribute.',\n    )\n}\n","import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { AccessList } from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\n\nexport type SerializeAccessListErrorType =\n  | InvalidStorageKeySizeErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/*\n * Serialize an  EIP-2930 access list\n * @remarks\n * Use to create a transaction serializer with support for EIP-2930 access lists\n *\n * @param accessList - Array of objects of address and arrays of Storage Keys\n * @throws InvalidAddressError, InvalidStorageKeySizeError\n * @returns Array of hex strings\n */\nexport function serializeAccessList(\n  accessList?: AccessList | undefined,\n): RecursiveArray<Hex> {\n  if (!accessList || accessList.length === 0) return []\n\n  const serializedAccessList = []\n  for (let i = 0; i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i]\n\n    for (let j = 0; j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\n      }\n    }\n\n    if (!isAddress(address, { strict: false })) {\n      throw new InvalidAddressError({ address })\n    }\n\n    serializedAccessList.push([address, storageKeys])\n  }\n  return serializedAccessList\n}\n","import {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  Signature,\n  SignatureLegacy,\n} from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from '../blob/blobsToCommitments.js'\nimport {\n  blobsToProofs,\n  type blobsToProofsErrorType,\n} from '../blob/blobsToProofs.js'\nimport {\n  type CommitmentsToVersionedHashesErrorType,\n  commitmentsToVersionedHashes,\n} from '../blob/commitmentsToVersionedHashes.js'\nimport {\n  type ToBlobSidecarsErrorType,\n  toBlobSidecars,\n} from '../blob/toBlobSidecars.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { trim } from '../data/trim.js'\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\n\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionEIP4844ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionEIP4844,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetTransactionType,\n  type GetTransationTypeErrorType,\n  getTransactionType,\n} from './getTransactionType.js'\nimport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './serializeAccessList.js'\n\nexport type SerializedTransactionReturnType<\n  transaction extends TransactionSerializable = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n> = TransactionSerialized<_transactionType>\n\nexport type SerializeTransactionFn<\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = never,\n> = typeof serializeTransaction<\n  OneOf<TransactionSerializable | transaction>,\n  _transactionType\n>\n\nexport type SerializeTransactionErrorType =\n  | GetTransationTypeErrorType\n  | SerializeTransactionEIP1559ErrorType\n  | SerializeTransactionEIP2930ErrorType\n  | SerializeTransactionEIP4844ErrorType\n  | SerializeTransactionLegacyErrorType\n  | ErrorType\n\nexport function serializeTransaction<\n  const transaction extends TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n>(\n  transaction: transaction,\n  signature?: Signature | undefined,\n): SerializedTransactionReturnType<transaction, _transactionType> {\n  const type = getTransactionType(transaction) as GetTransactionType\n\n  if (type === 'eip1559')\n    return serializeTransactionEIP1559(\n      transaction as TransactionSerializableEIP1559,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip2930')\n    return serializeTransactionEIP2930(\n      transaction as TransactionSerializableEIP2930,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip4844')\n    return serializeTransactionEIP4844(\n      transaction as TransactionSerializableEIP4844,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  return serializeTransactionLegacy(\n    transaction as TransactionSerializableLegacy,\n    signature as SignatureLegacy,\n  ) as SerializedTransactionReturnType<transaction>\n}\n\ntype SerializeTransactionEIP4844ErrorType =\n  | AssertTransactionEIP4844ErrorType\n  | BlobsToCommitmentsErrorType\n  | CommitmentsToVersionedHashesErrorType\n  | blobsToProofsErrorType\n  | ToBlobSidecarsErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP4844 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP4844(transaction)\n\n  let blobVersionedHashes = transaction.blobVersionedHashes\n  let sidecars = transaction.sidecars\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\n  if (\n    transaction.blobs &&\n    (typeof blobVersionedHashes === 'undefined' ||\n      typeof sidecars === 'undefined')\n  ) {\n    const blobs = (\n      typeof transaction.blobs[0] === 'string'\n        ? transaction.blobs\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\n    ) as Hex[]\n    const kzg = transaction.kzg!\n    const commitments = blobsToCommitments({\n      blobs,\n      kzg,\n    })\n\n    if (typeof blobVersionedHashes === 'undefined')\n      blobVersionedHashes = commitmentsToVersionedHashes({\n        commitments,\n      })\n    if (typeof sidecars === 'undefined') {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\n    }\n  }\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...toYParitySignatureArray(transaction, signature),\n  ] as const\n\n  const blobs: Hex[] = []\n  const commitments: Hex[] = []\n  const proofs: Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return concatHex([\n    '0x03',\n    sidecars\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\n        toRlp([serializedTransaction, blobs, commitments, proofs])\n      : // If sidecars are disabled, standard envelope is used:\n        toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP4844\n}\n\ntype SerializeTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP1559 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP1559(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x02',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP1559\n}\n\ntype SerializeTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP2930 {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\n    transaction\n\n  assertTransactionEIP2930(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x01',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP2930\n}\n\ntype SerializeTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nfunction serializeTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n  signature?: SignatureLegacy | undefined,\n): TransactionSerializedLegacy {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\n\n  assertTransactionLegacy(transaction)\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n  ]\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n\n        if (inferredChainId > 0) return signature.v\n        return 27n + (signature.v === 35n ? 0n : 1n)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\n      return v\n    })()\n\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(v),\n      signature.r,\n      signature.s,\n    ]\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      '0x',\n      '0x',\n    ]\n  }\n\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\n}\n\nexport function toYParitySignatureArray(\n  transaction: TransactionSerializableGeneric,\n  signature?: Signature | undefined,\n) {\n  const { r, s, v, yParity } = signature ?? transaction\n  if (typeof r === 'undefined') return []\n  if (typeof s === 'undefined') return []\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\n\n  const yParity_ = (() => {\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\n    if (v === 0n) return '0x'\n    if (v === 1n) return toHex(1)\n\n    return v === 27n ? '0x' : toHex(1)\n  })()\n  return [yParity_, trim(r), trim(s)]\n}\n","import { serializeTransaction } from \"viem\";\nimport { getContract } from \"../contract/contract.js\";\nimport { toSerializableTransaction } from \"../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { readContract } from \"../transaction/read-contract.js\";\n\nexport type EstimateL1FeeOptions = {\n  transaction: PreparedTransaction;\n  gasPriceOracleAddress?: string;\n};\n\nconst OPStackGasPriceOracleAddress =\n  \"0x420000000000000000000000000000000000000F\";\n\n/**\n * @internal\n */\nexport async function estimateL1Fee(options: EstimateL1FeeOptions) {\n  const { transaction, gasPriceOracleAddress } = options;\n  const oracleContract = getContract({\n    client: transaction.client,\n    address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,\n    chain: transaction.chain,\n  });\n\n  // purposefully remove gasPrice from the transaction\n\n  const { gasPrice, ...serializableTx } = await toSerializableTransaction({\n    transaction,\n  });\n  const serialized = serializeTransaction({\n    ...serializableTx,\n    type: \"eip1559\",\n  });\n  //serializeTransaction(transaction);\n  return readContract({\n    contract: oracleContract,\n    method: \"function getL1Fee(bytes memory _data) view returns (uint256)\",\n    params: [serialized],\n  });\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n"],"names":["assertTransactionEIP1559","transaction","chainId","maxPriorityFeePerGas","maxFeePerGas","to","InvalidChainIdError","isAddress","InvalidAddressError","address","FeeCapTooHighError","TipAboveFeeCapError","serializeAccessList","accessList","length","serializedAccessList","i","storageKeys","j","InvalidStorageKeySizeError","storageKey","strict","push","serializeTransaction","signature","type","getTransactionType","gas","nonce","value","data","serializedTransaction","toHex","toYParitySignatureArray","concatHex","toRlp","serializeTransactionEIP1559","gasPrice","BaseError","assertTransactionEIP2930","serializeTransactionEIP2930","_blobVersionedHashes","maxFeePerBlobGas","blobVersionedHashes","EmptyBlobError","hash","size_","size","version","hexToNumber","slice","InvalidVersionedHashSizeError","versionedHashVersionKzg","InvalidVersionedHashVersionError","assertTransactionEIP4844","sidecars","blobs","map","x","bytesToHex","kzg","commitments","blobsToCommitments","commitmentsToVersionedHashes","proofs","blobsToProofs","toBlobSidecars","blob","commitment","proof","serializeTransactionEIP4844","assertTransactionLegacy","v","BigInt","InvalidLegacyVError","r","s","serializeTransactionLegacy","yParity","trim","OPStackGasPriceOracleAddress","async","estimateL1Fee","options","gasPriceOracleAddress","oracleContract","getContract","client","chain","serializableTx","toSerializableTransaction","serialized","readContract","contract","method","params","bytes","arguments","undefined","encodable","getEncodable","cursor","createCursor","Uint8Array","encode","Array","isArray","list","bodyLength","reduce","acc","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","hexToBytes","sizeOfBytesLength","pushBytes","getEncodableBytes"],"sourceRoot":""}