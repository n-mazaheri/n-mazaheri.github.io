{"version":3,"file":"static/js/90267.1e637cf9.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/wallets/wallet-connect/constants.ts","../node_modules/thirdweb/src/wallets/wallet-connect/controller.ts"],"sourcesContent":["export const DEFAULT_PROJECT_ID = \"08c4b07e3ad25f1a27c14a4e8cecb6f0\";\n\nexport const NAMESPACE = \"eip155\";\n","import type { EthereumProvider } from \"@walletconnect/ethereum-provider\";\nimport type { Address } from \"abitype\";\nimport {\n  type ProviderRpcError,\n  type SignTypedDataParameters,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport {\n  getCachedChain,\n  getChainMetadata,\n  getRpcUrlForChain,\n} from \"../../chains/utils.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport type { WCSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WCAutoConnectOptions, WCConnectOptions } from \"./types.js\";\n\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport {\n  getSavedConnectParamsFromStorage,\n  saveConnectParamsToStorage,\n} from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\n\ntype WCProvider = InstanceType<typeof EthereumProvider>;\n\ntype SavedConnectParams = {\n  optionalChains?: Chain[];\n  chain?: Chain;\n  pairingTopic?: string;\n};\n\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\n\nconst defaultShowQrModal = true;\n\nconst storageKeys = {\n  requestedChains: \"tw.wc.requestedChains\",\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n};\n\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"walletConnect\"> {\n  return wallet.id === \"walletConnect\";\n}\n\n/**\n * @internal\n */\nexport async function connectWC(\n  options: WCConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n\n  let { onDisplayUri } = wcOptions || {};\n\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler) {\n    const walletInfo = await getWalletInfo(walletId);\n    const deeplinkHandler = (uri: string) => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        throw new Error(\"No app url found for wallet connect to redirect to.\");\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n\n  const { rpcMap, chainsToRequest } = getChainsToRequest({\n    client: options.client,\n    chain: options.chain,\n    optionalChains: options.walletConnect?.optionalChains,\n  });\n\n  if (provider.session) {\n    await provider.connect({\n      ...(wcOptions?.pairingTopic\n        ? { pairingTopic: wcOptions?.pairingTopic }\n        : {}),\n      optionalChains: chainsToRequest,\n      chains: options.chain\n        ? [options.chain.id]\n        : chainsToRequest.length > 0\n          ? [chainsToRequest[0]]\n          : [1],\n      rpcMap: rpcMap,\n    });\n  }\n\n  setRequestedChainsIds(chainsToRequest, storage);\n  // If session exists and chains are authorized, enable provider for required chain\n  const addresses = await provider.enable();\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  if (options) {\n    const savedParams: SavedConnectParams = {\n      optionalChains: options.walletConnect?.optionalChains,\n      chain: options.chain,\n      pairingTopic: options.walletConnect?.pairingTopic,\n    };\n\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n\n  if (wcOptions?.onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", wcOptions.onDisplayUri);\n  }\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(\n  options: WCAutoConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const savedConnectParams: SavedConnectParams | null = storage\n    ? await getSavedConnectParamsFromStorage(storage, walletId)\n    : null;\n\n  const provider = await initProvider(\n    savedConnectParams\n      ? {\n          chain: savedConnectParams.chain,\n          client: options.client,\n          walletConnect: {\n            pairingTopic: savedConnectParams.pairingTopic,\n            optionalChains: savedConnectParams.optionalChains,\n          },\n        }\n      : {\n          client: options.client,\n          walletConnect: {},\n        },\n    walletId,\n    sessionHandler,\n    true, // is auto connect\n  );\n\n  const address = provider.accounts[0];\n\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n// Connection utils -----------------------------------------------------------------------------------------------\n\nasync function initProvider(\n  options: WCConnectOptions,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  sessionRequestHandler?: (uri: string) => void,\n  isAutoConnect = false,\n) {\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await import(\n    \"@walletconnect/ethereum-provider\"\n  );\n\n  const { rpcMap, chainsToRequest } = getChainsToRequest({\n    client: options.client,\n    chain: options.chain,\n    optionalChains: options.walletConnect?.optionalChains,\n  });\n\n  const provider = await EthereumProvider.init({\n    showQrModal: sessionRequestHandler\n      ? false\n      : wcOptions?.showQrModal === undefined\n        ? defaultShowQrModal\n        : wcOptions.showQrModal,\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n    optionalMethods: OPTIONAL_METHODS,\n    optionalEvents: OPTIONAL_EVENTS,\n    optionalChains: chainsToRequest,\n    chains: options.chain\n      ? [options.chain.id]\n      : chainsToRequest.length > 0\n        ? [chainsToRequest[0]]\n        : [1],\n    metadata: {\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      description:\n        wcOptions?.appMetadata?.description ||\n        getDefaultAppMetadata().description,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      icons: [\n        wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      ],\n    },\n    rpcMap: rpcMap,\n    qrModalOptions: wcOptions?.qrModalOptions,\n    disableProviderPing: true,\n  });\n\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n\n  // disconnect the provider if chains are stale when (if not auto connecting)\n  if (!isAutoConnect) {\n    // const isStale = await isChainsStale(provider, chainsToRequest);\n\n    if (provider.session) {\n      await provider.disconnect();\n    }\n  }\n\n  if (walletId !== \"walletConnect\") {\n    function handleSessionRequest() {\n      const walletLinkToOpen =\n        provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n\n      if (sessionRequestHandler && walletLinkToOpen) {\n        sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n\n    provider.signer.client.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.signer.client.off(\"session_request_sent\", handleSessionRequest);\n    });\n  }\n\n  return provider;\n}\n\nfunction createAccount(provider: WCProvider, address: string) {\n  const account: Account = {\n    address,\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            from: this.address,\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, this.address],\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const { domain, message, primaryType } =\n        data as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...data.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.address, typedData],\n      });\n    },\n  };\n\n  return account;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: WCProvider,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  storage: AsyncStorage,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount(provider, address);\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount(provider, getAddress(accounts[0]));\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChainWC(provider, newChain, storage),\n  ];\n}\n\n// Storage utils  -----------------------------------------------------------------------------------------------\n\nfunction getNamespaceMethods(provider: WCProvider) {\n  return provider.session?.namespaces[NAMESPACE]?.methods || [];\n}\n\nfunction getNamespaceChainsIds(provider: WCProvider): number[] {\n  const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map(\n    (chain) => Number.parseInt(chain.split(\":\")[1] || \"\"),\n  );\n\n  return chainIds ?? [];\n}\n\nasync function switchChainWC(\n  provider: WCProvider,\n  chain: Chain,\n  storage: AsyncStorage,\n) {\n  const chainId = chain.id;\n  try {\n    const namespaceChains = getNamespaceChainsIds(provider);\n    const namespaceMethods = getNamespaceMethods(provider);\n    const isChainApproved = namespaceChains.includes(chainId);\n\n    if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n      const apiChain = await getChainMetadata(chain);\n\n      await provider.request({\n        method: ADD_ETH_CHAIN_METHOD,\n        params: [\n          {\n            chainId: numberToHex(apiChain.chainId),\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no clientId on purpose\n            blockExplorerUrls:\n              chain.blockExplorers?.slice(0, 1) ||\n              apiChain.explorers?.slice(0, 1) ||\n              [],\n          },\n        ],\n      });\n      const requestedChains = await getRequestedChainsIds(storage);\n      requestedChains.push(chainId);\n      setRequestedChainsIds(requestedChains, storage);\n    }\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: numberToHex(chainId) }],\n    });\n  } catch (error) {\n    const message =\n      typeof error === \"string\" ? error : (error as ProviderRpcError)?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error as Error);\n    }\n\n    throw new SwitchChainError(error as Error);\n  }\n}\n\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(chains: number[], storage: AsyncStorage) {\n  storage?.setItem(storageKeys.requestedChains, JSON.stringify(chains));\n}\n\n/**\n * Get the last requested chains from the storage.\n * @internal\n */\nasync function getRequestedChainsIds(storage: AsyncStorage): Promise<number[]> {\n  const data = await storage.getItem(storageKeys.requestedChains);\n  return data ? JSON.parse(data) : [];\n}\n\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\nfunction getChainsToRequest(options: {\n  chain?: Chain;\n  optionalChains?: Chain[];\n  client: ThirdwebClient;\n}) {\n  const rpcMap: Record<number, string> = {};\n\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n  }\n\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client,\n    });\n  }\n\n  const optionalChainIds = optionalChains.map((c) => c.id) || [];\n\n  const chainsToRequest: ArrayOneOrMore<number> = options.chain\n    ? [options.chain.id, ...optionalChainIds]\n    : optionalChainIds.length > 0\n      ? (optionalChainIds as ArrayOneOrMore<number>)\n      : [1];\n\n  if (!options.chain && optionalChains.length === 0) {\n    rpcMap[1] = getCachedChain(1).rpc;\n  }\n\n  return {\n    rpcMap,\n    chainsToRequest,\n  };\n}\n"],"names":["DEFAULT_PROJECT_ID","NAMESPACE","ADD_ETH_CHAIN_METHOD","defaultShowQrModal","storageKeys","requestedChains","lastUsedChainId","async","connectWC","options","emitter","walletId","storage","sessionHandler","_options$walletConnec","provider","initProvider","wcOptions","walletConnect","onDisplayUri","walletInfo","getWalletInfo","uri","appUrl","mobile","native","universal","Error","fullUrl","formatWalletConnectUrl","redirect","events","addListener","rpcMap","chainsToRequest","getChainsToRequest","client","chain","optionalChains","session","connect","pairingTopic","chains","id","length","setRequestedChainsIds","address","enable","providerChainId","normalizeChainId","chainId","getCachedChain","_options$walletConnec2","_options$walletConnec3","savedParams","saveConnectParamsToStorage","removeListener","onConnect","autoConnectWC","savedConnectParams","getSavedConnectParamsFromStorage","accounts","sessionRequestHandler","_options$walletConnec4","_wcOptions$appMetadat","_wcOptions$appMetadat2","_wcOptions$appMetadat3","_wcOptions$appMetadat4","isAutoConnect","arguments","undefined","EthereumProvider","OPTIONAL_EVENTS","OPTIONAL_METHODS","init","showQrModal","projectId","optionalMethods","optionalEvents","metadata","name","appMetadata","getDefaultAppMetadata","description","url","icons","logoUrl","qrModalOptions","disableProviderPing","setMaxListeners","Number","POSITIVE_INFINITY","disconnect","handleSessionRequest","_provider$session","walletLinkToOpen","peer","signer","on","off","createAccount","sendTransaction","tx","transactionHash","request","method","params","gas","numberToHex","value","from","this","to","data","signMessage","_ref","message","messageToSign","stringToHex","raw","Uint8Array","uint8ArrayToHex","signTypedData","_data","parseTypedData","domain","primaryType","types","EIP712Domain","getTypesForEIP712Domain","validateTypedData","typedData","serializeTypedData","account","onAccountsChanged","onChainChanged","onDisconnect","removeItem","emit","newAccount","getAddress","newChainId","newChain","setItem","String","namespaceChains","_provider$session3","chainIds","namespaces","map","parseInt","split","getNamespaceChainsIds","namespaceMethods","_provider$session2","methods","getNamespaceMethods","includes","_chain$blockExplorers","_apiChain$explorers","apiChain","getChainMetadata","chainName","nativeCurrency","rpcUrls","getValidPublicRPCUrl","blockExplorerUrls","blockExplorers","slice","explorers","getItem","JSON","parse","getRequestedChainsIds","push","error","test","UserRejectedRequestError","SwitchChainError","switchChainWC","stringify","getRpcUrlForChain","optionalChainIds","c","rpc"],"sourceRoot":""}